### 命令式与声明式
命令式框架关注过程，声明式框架关注结果
<div @click="() => alert('ok')">hello world</div>
vue内部实现一定是命令式的，而暴露给用户的更加声明式

声明式代码的性能不优于命令式代码的性能，但是声明式代码的可维护性更强
声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗
最小化找出差异的性能消耗：虚拟DOM
虚拟DOM要解决的问题：在声明式范式下使找出差异的性能消耗最小化

### 虚拟DOM性能
innerHTML创建页面的性能：HTML字符串拼接的计算量 + innerHTML的DOM计算量
虚拟DOM创建页面的性能：创建javascript对象的计算量 + 创建真实DOM的计算量

使用innerHTML更新页面的过程是重新构建html字符串，再重新设置DOM元素的innerHTML属性。重新设置innerHTML属性等价于销毁所有旧的DOM元素，再全量创建新DOM元素
虚拟DOM更新页面：重新创建javascript对象(虚拟DOM树)，然后比较新旧虚拟DOM，找到变化的元素并更新它

因此，更新页面时虚拟DOM在js层面的运算要比创建页面时多出一个Diff的性能消耗，但是它是js层面的运算，所以不会产生数量级的差异。
况且，虚拟DOM只更新必要元素，innerHTML全量更新，并且页面越大，innerHTML更新的性能消耗越大。虚拟DOM的优势

![Alt text](image00486-1.jpeg)

### 运行(Runtime)和编译时(Compile-time)
vue3仍保持了运行时+编译时的架构，在保持灵活性的基础上，也能通过编译手段分析用户提供的内容，从而进一步提升更新性能

### 框架设计
Tree-Shaking机制：为框架设计带来灵活性
IIFE格式：立即调用的函数表达式 (function(){}())
带有-bundler的ESM资源是给webpack等打包工具使用的
带有-browser的ESM资源是直接给<script type="module"></script>使用的

为用户提供统一的错误处理接口：
```js
// util.js
    let handleError = null

    export default{
        foo(fn) {
            callWithErrorHandling(fn);
        },
        // 用户可以调用该函数 注册统一的错误处理函数
        registerErrorHandler(fn) {
            handleError=fn
        }
    }
    
    function callWithErrorHandling(fn) {
        try{
            fn && fn() // 这是用于执行函数fn的方式，能够避免在函数不存在时引发错误
        } catch(e) {
            // 将捕获到的错误传递给用户的错误处理程序
            handleError(e)
        }
    }
```
这样用户侧的代码就会非常简洁且健壮
```js
    import utils from 'utils.js'
    // 注册用户处理程序
    utils.registerErrorHandler((e)=> {console.log(e)})

    utils.foo(()=>{...})
```

在Vue.js中注册统一的错误处理函数
```js
    import App from 'App.vue'
    const app = createApp(App)
    app.config.errorHandler=()=> {
        // 错误处理程序
    }

```